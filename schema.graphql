schema {
  query: QueryRoot
  mutation: Mutation
}

type BasicGroup {
  name: String!
  priority: Int!
  defaultSettings: Int!
  description: String
  groupType: BasicGroupKind!
  options: [BasicOptionItem!]!
}

enum BasicGroupKind {
  SINGLE
  MULTI
  IMC
}

type BasicOptionItem {
  name: String!
  description: String
  imagePath: String
}

scalar BatchList

"Implement the DateTime<Utc> scalar\n\nThe input\/output is a string in RFC3339 format."
scalar DateTime

enum DownloadKind {
  INSTALL
  UPDATE
}

type ExtraFile {
  path: String!
  size: Int!
}

type ExtraFileArchive {
  id: UUID!
  hash: String!
  name: String!
  sizeCompressed: Int!
  files: [ExtraFile!]!
}

scalar FileList

scalar FileSwaps

input FilterInfo {
  nsfw: Boolean!
  nsfl: Boolean!
  paid: Boolean!
}

type FullUser {
  id: UUID!
  username: String!
  level: UserLevel!
  email: String!
  emailVerified: Boolean!
  subscriber: Boolean!
  vanityUrl: String
  vanityUrls: Int!
  tokenId: Int!
  totpEnabled: Boolean!
  verificationLevel: VerificationLevel!
  tokens: [Token!]!
  usedStorage: Int!
  usedVanityUrls: Int!
  tasks: [Task!]!
  hashes: [String!]!
  profile: Profile!
  webhook: Webhook
  patreonConnected: Boolean!
  isPatreonCreator: Boolean!
  patreonTiers(force: Boolean!): [Tier!]
  installQueue: [Version!]!
  maxUploadSize: Int!
  templates: [Template!]!
}

type Group implements GroupInterface {
  name: String!
  priority: Int!
  defaultSettings: Int!
  description: String
  groupType: GroupType!
  options: [OptionItem!]!
  originalIndex: Int!
}

type GroupContainer {
  standard: [Group!]!
  imc: [GroupImc!]!
}

type GroupImc implements GroupInterface {
  name: String!
  priority: Int!
  defaultSettings: Int!
  description: String
  groupType: GroupType!
  identifier: JSON!
  defaultEntry: JSON!
  options: [OptionItemImc!]!
  originalIndex: Int!
}

interface GroupInterface {
  name: String!
  priority: Int!
  defaultSettings: Int!
  description: String
  groupType: GroupType!
  originalIndex: Int!
}

type GroupManipulations {
  name: String
  options: [OptionManipulations!]!
}

enum GroupType {
  SINGLE
  MULTI
  IMC
}

type Image {
  id: Int!
  hash: String!
  displayOrder: Int!
  thumbhash: Thumbhash
  dominantColours(limit: Int): [Int!]
}

enum InstallQueueUpdate {
  ADD
  REMOVE
}

scalar InstallerImageList

type InstallerImages {
  baseUri: String!
  images: InstallerImageList!
}

"A scalar that can represent any JSON Object value."
scalar JSONObject

type LoginResponse {
  id: UUID!
  username: String!
  token: String!
}

type Mutation {
  login(username: String! password: String! totpCode: String): LoginResponse!
  logout: Int!
  register(username: String! email: String! password: String! token: String!): RegisterResponse!
  deleteToken(id: Int!): Int!
  deleteAllTokens(except: Int): Int!
  createPackage(package: PackageInput!): Package!
  updatePackage(id: UUID! update: UpdatePackageInput!): Int!
  deletePackage(id: UUID! reason: String): Int!
  updateUser(update: UpdateUserInput!): Int!
  deleteUser: Int!
  reorderImages(ordering: JSONObject!): Int!
  deleteImages(ids: [Int!]!): Int!
  updateVersion(id: UUID! input: UpdateVersionInput!): Int!
  deleteVersion(id: UUID!): Int!
  createVariant(input: VariantInput!): Variant!
  updateVariant(id: UUID! input: UpdateVariantInput!): Int!
  deleteVariant(id: UUID!): Int!
  updateProfile(update: UpdateProfileInput!): Int!
  updateUserWebhook(webhook: WebhookInput): Int!
  resendEmailVerification(token: String!): Int!
  updateTotpSettings(change: JSON!): JSON!
  createPatreonDownloadKey(packageId: UUID!): String
  updateInstallQueue(updates: [UpdateInstallQueueInput!]!): Int!
  createTemplate(input: TemplateInput!): UUID!
  updateTemplate(id: UUID! update: UpdateTemplateInput!): Int!
  deleteTemplate(id: UUID!): Int!
  deleteExtraFile(id: UUID!): Int!
  copyExtraFiles(from: UUID! to: UUID!): Int!
  report(token: String! packageId: UUID! report: JSON!): Int!
  updateVariantDisplayOrders(packageId: UUID! variantIdsInOrder: [UUID!]!): Int!
  dismissReport(id: UUID! reason: String!): Int!
  requestVerification(name: String! description: String!): Int!
  updateVerificationRequest(requesterId: UUID! accepted: Boolean!): Int!
}

type NeededFiles {
  baseUri: String!
  manipulations: [GroupManipulations!]!
  files: FileList!
  modHash: String
}

interface OptionInterface {
  name: String!
  description: String
}

type OptionItem implements OptionInterface {
  name: String!
  priority: Int!
  imagePath: String
  description: String
  gamePaths: [String!]!
  manipulations: [JSON!]!
  fileSwaps: FileSwaps!
  isDefault: Boolean!
}

type OptionItemImc implements OptionInterface {
  name: String!
  description: String
  isDisableSubMod: Boolean
  attributeMask: Int
}

type OptionManipulations {
  name: String
  manipulations: [JSON!]!
}

scalar Options

enum Order {
  DOWNLOADS
  DOWNLOADED_AT
  CREATED_AT
  UPDATED_AT
  SIMILARITY
  DOWNLOADS_LAST_MONTH
  DOWNLOADS_AVERAGE
}

type Package {
  id: UUID!
  userId: UUID!
  createdAt: DateTime!
  updatedAt: DateTime!
  name: String!
  tagline: String!
  description: String!
  permissions: String
  visibility: PackageVisibility!
  patreon: Boolean!
  patreonTiers: [String!]!
  user: User!
  variants: [Variant!]!
  downloads: Int!
  tags: [Tag!]!
  nsfw: RestrictedInfo!
  images: [Image!]!
  rawVanityUrl: String
  vanityUrl: String
  webhook: Webhook
  userIsEntitled: Boolean!
  auditLog: [PackageAuditLogEntry!]!
}

type PackageAuditLogEntry {
  explanation: String!
  reason: String!
  timestamp: DateTime!
}

input PackageInput {
  name: String!
  tagline: String!
  description: String!
  permissions: String
  tags: [String!]!
  webhook: WebhookInput
  visibility: PackageVisibility!
  patreon: Boolean! = false
  patreonTiers: [String!]! = [  ]
}

enum PackageVisibility {
  "Hidden by a moderator."
  HIDDEN
  DRAFT
  PUBLIC
  UNLISTED
  PRIVATE
}

type PaginatedPackages {
  pageInfo: SimplePageInfo!
  packages: [Package!]!
}

type Profile {
  description: String
  avatarId: String
  accent: String
  shape: String!
  links: JSON!
  thumbhash: Thumbhash
}

type QueryRoot {
  package(id: UUID!): Package
  variant(id: UUID!): Variant
  variants(ids: [UUID!]!): [Variant!]!
  featuredPackages(page: Int! count: Int! filterInfo: FilterInfo): PaginatedPackages!
  packages(page: Int! count: Int! filterInfo: FilterInfo): PaginatedPackages!
  me: FullUser
  user(id: UUID!): User
  userModerationView(id: UUID!): UserModerationView
  getVersion(id: UUID!): Version
  task(id: UUID!): Task
  categoryTags: [Tag!]!
  searchTags(query: String!): [TagSearchResult!]!
  searchAffects(query: String!): [String!]!
  searchVersions(info: SearchRequest! filterInfo: FilterInfo amount: Int! = 9 page: Int): SearchResult!
  recentlyUpdatedPackages(page: Int! count: Int! filterInfo: FilterInfo): RecentPackages!
  recentlyDownloadedPackages(page: Int! count: Int! filterInfo: FilterInfo): RecentPackages!
  checkVanityUrl(kind: VanityUrlKind! slug: String!): UUID
  convertVariantId(id: Int!): UUID
  convertVersionId(id: Int!): UUID
  template(id: UUID!): Template
  reports: [StoredReport!]!
  reportsDismissed: [StoredReport!]!
  moderatorPackages(visibility: PackageVisibility! page: Int! count: Int!): PaginatedPackages!
  verificationRequests: [VerificationRequest!]!
  verificationRequestsDismissed: [VerificationRequest!]!
}

type RecentPackage {
  package: Package!
  timestamp: DateTime!
}

type RecentPackages {
  pageInfo: SimplePageInfo!
  packages: [RecentPackage!]!
}

type RegisterResponse {
  id: UUID!
  username: String!
  token: String!
}

type RestrictedInfo {
  nsfw: Boolean!
  nsfl: Boolean!
}

enum SearchDirection {
  ASCENDING
  DESCENDING
}

input SearchRequest {
  name: String
  author: String
  affects: [String!]! = [  ]
  includeTags: [String!]! = [  ]
  excludeTags: [String!]! = [  ]
  order: Order!
  direction: SearchDirection! = DESCENDING
  subscriber: SubscriberStatus! = ALL
}

type SearchResult {
  versions: [Version!]!
  pageInfo: SimplePageInfo!
}

type SimplePageInfo {
  prev: Boolean!
  next: Boolean!
  total: Int!
}

type StoredReport {
  id: UUID!
  packageId: UUID!
  reporterId: UUID
  report: JSON!
  dismisserId: UUID
  dismissalReason: String
  createdAt: DateTime
  package: Package
  reporter: User
  dismisser: User
}

enum SubscriberStatus {
  ALL
  SUBSCRIBER
  NON_SUBSCRIBER
}

type Tag {
  slug: String!
  category: Boolean!
}

type TagSearchResult {
  slug: String!
  category: Boolean!
  packages: Int!
}

type Task {
  id: UUID!
  kind: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  scheduledFor: DateTime!
  status: TaskStatus!
  retries: Int!
  output: JSON!
}

enum TaskStatus {
  QUEUED
  RUNNING
  SUCCESS
  FAILURE
}

type Template {
  id: UUID!
  templateName: String!
  modName: String
  tagline: String
  description: String
  permissions: String
  visibility: PackageVisibility!
  patreon: Boolean!
  patreonTiers: [String!]!
  tags: [String!]!
  variables: [String!]!
}

input TemplateInput {
  templateName: String!
  modName: String
  tagline: String
  description: String
  permissions: String
  tags: [String!]!
  visibility: PackageVisibility!
  patreon: Boolean!
  patreonTiers: [String!]!
  variables: [String!]!
}

type Thumbhash {
  hash: String!
  width: Int!
  height: Int!
}

type Tier {
  id: String!
  title: String!
  published: Boolean!
  amountUsdCents: Int!
  updatedAt: DateTime!
}

type Token {
  id: Int!
  userAgent: String
  updatedAt: DateTime!
  continent: String
  country: String
  city: String
}

"A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as\nStrings within GraphQL. UUIDs are used to assign unique identifiers to\nentities without requiring a central allocating authority.\n\n# References\n\n* [Wikipedia: Universally Unique Identifier](http:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier)\n* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http:\/\/tools.ietf.org\/html\/rfc4122)"
scalar UUID

input UpdateInstallQueueInput {
  action: InstallQueueUpdate!
  versionId: UUID!
}

input UpdatePackageInput {
  name: String
  tagline: String
  description: String
  vanityUrl: JSON!
  permissions: JSON!
  webhook: JSON! = "{\"kind\":\"ignore\"}"
  addTags: [String!]! = [  ]
  removeTags: [String!]! = [  ]
  visibility: PackageVisibility
  patreon: Boolean
  patreonTiers: [String!]
  reason: String
}

input UpdateProfileInput {
  description: JSON!
  vanityUrl: JSON!
  shape: String
  accent: JSON!
  links: JSON
}

input UpdateTemplateInput {
  templateName: String
  modName: JSON!
  tagline: JSON!
  description: JSON!
  permissions: JSON!
  tags: [String!]
  visibility: PackageVisibility
  patreon: Boolean
  patreonTiers: [String!]
  variables: [String!]
}

input UpdateUserInput {
  username: String
  email: String
  newPassword: String
  password: String!
}

input UpdateVariantInput {
  name: String
}

input UpdateVersionInput {
  version: String
  changelog: JSON! = "{\"kind\":\"ignore\"}"
  variant: UUID
  dependencies: JSON
}

type User {
  id: UUID!
  username: String!
  subscriber: Boolean!
  vanityUrl: String
  packages(page: Int! count: Int! filterInfo: FilterInfo): PaginatedPackages!
  profile: Profile!
  patreonTiers: [Tier!]
  patreonPledgeUrl: String
}

enum UserLevel {
  USER
  MODERATOR
  ADMIN
}

type UserModerationView {
  id: UUID!
  username: String!
  email: String!
  subscriber: Boolean!
  vanityUrl: String
}

enum VanityUrlKind {
  USER
  MOD
}

type Variant {
  id: UUID!
  name: String!
  packageId: UUID!
  displayOrder: Int!
  package: Package!
  versions(limit: Int): [Version!]!
}

input VariantInput {
  packageId: UUID!
  name: String!
}

enum VerificationLevel {
  UNVERIFIED
  IN_PROGRESS
  VERIFIED
  DENIED
}

type VerificationRequest {
  userId: UUID!
  createdAt: DateTime!
  responses: JSON!
  accepted: Boolean
  reviewerId: UUID
  user: UserModerationView
  reviewer: User
}

type Version {
  id: UUID!
  variantId: UUID!
  version: String!
  changelog: String
  createdAt: DateTime!
  updatedAt: DateTime!
  affects: [String!]!
  batched: Boolean!
  dependencies: JSON!
  variant: Variant!
  installerImages: InstallerImages!
  gamePaths: [String!]!
  downloadSize: Int!
  installSize: Int!
  neededFiles(options: Options full: Boolean download: Boolean downloadKey: String downloadKind: DownloadKind): NeededFiles!
  defaultOption: OptionItem
  groups: GroupContainer!
  basicGroups: [BasicGroup!]!
  batches: BatchList!
  downloads: Int!
  extraFiles: [ExtraFileArchive!]!
  fullDependencies: JSON!
}

type Webhook {
  id: Int!
  createdAt: DateTime!
  url: String!
  nsfwImages: Boolean!
  userId: UUID
  packageId: UUID
}

input WebhookInput {
  url: String!
  nsfwImages: Boolean!
}