schema {
    query: QueryRoot
    mutation: Mutation
}

"Implement the DateTime<Utc> scalar\n\nThe input\/output is a string in RFC3339 format."
scalar DateTime

type FeaturedPackages {
    pageInfo: SimplePageInfo!
    packages: [Package!]!
}

scalar FileList

input FilterInfo {
    nsfw: Boolean!
    nsfl: Boolean!
    paid: Boolean!
}

type FullUser {
    id: UUID!
    username: String!
    email: String!
    emailVerified: Boolean!
    subscriber: Boolean!
    vanityUrl: String
    vanityUrls: Int!
    tokenId: Int!
    totpEnabled: Boolean!
    tokens: [Token!]!
    usedStorage: Int!
    usedVanityUrls: Int!
    tasks: [Task!]!
    hashes: [String!]!
    profile: Profile!
    webhook: Webhook
    patreonConnected: Boolean!
    isPatreonCreator: Boolean!
    patreonTiers(force: Boolean!): [Tier!]
}

type Group {
    name: String!
    priority: Int!
    defaultSettings: Int!
    description: String
    selectionType: SelectionType!
    options: [OptionItem!]!
}

type GroupManipulations {
    name: String
    options: [OptionManipulations!]!
}

type Image {
    id: Int!
    hash: String!
    displayOrder: Int!
    thumbhash: String
}

scalar InstallerImageList

type InstallerImages {
    baseUri: String!
    images: InstallerImageList!
}

"A scalar that can represent any JSON Object value."
scalar JSONObject

type LoginResponse {
    id: UUID!
    username: String!
    token: String!
}

type Mutation {
    login(username: String! password: String! totpCode: String): LoginResponse!
    logout: Int!
    register(username: String! email: String! password: String!): RegisterResponse!
    deleteToken(id: Int!): Int!
    deleteAllTokens(except: Int): Int!
    createPackage(package: PackageInput!): Package!
    updatePackage(id: UUID! update: UpdatePackageInput!): Int!
    deletePackage(id: UUID!): Int!
    updateUser(update: UpdateUserInput!): Int!
    deleteUser: Int!
    reorderImages(ordering: JSONObject!): Int!
    deleteImages(ids: [Int!]!): Int!
    updateVersion(id: UUID! input: UpdateVersionInput!): Int!
    deleteVersion(id: UUID!): Int!
    createVariant(input: VariantInput!): Variant!
    updateVariant(id: UUID! input: UpdateVariantInput!): Int!
    deleteVariant(id: UUID!): Int!
    updateProfile(update: UpdateProfileInput!): Int!
    updateUserWebhook(webhook: WebhookInput): Int!
    resendEmailVerification(token: String!): Int!
    updateTotpSettings(change: JSON!): JSON!
    createPatreonDownloadKey(packageId: UUID!): String
}

type NeededFiles {
    baseUri: String!
    manipulations: [GroupManipulations!]!
    files: FileList!
    modHash: String
}

type OptionItem {
    name: String!
    priority: Int!
    imagePath: String
    description: String
    gamePaths: [String!]!
    manipulations: [JSON!]!
    isDefault: Boolean!
}

type OptionManipulations {
    name: String
    manipulations: [JSON!]!
}

scalar Options

enum Order {
    DOWNLOADS
    CREATED_AT
    UPDATED_AT
    SIMILARITY
}

type Package {
    id: UUID!
    userId: UUID!
    createdAt: DateTime!
    updatedAt: DateTime!
    name: String!
    tagline: String!
    description: String!
    permissions: String
    visibility: PackageVisibility!
    patreon: Boolean!
    patreonTiers: [String!]!
    user: User!
    variants: [Variant!]!
    downloads: Int!
    tags: [Tag!]!
    nsfw: RestrictedInfo!
    images: [Image!]!
    vanityUrl: String
    webhook: Webhook
    userIsEntitled: Boolean!
}

type PackageConnection {
    "Information to aid in pagination."
    pageInfo: PageInfo!
    "A list of edges."
    edges: [PackageEdge!]!
    "A list of nodes."
    nodes: [Package!]!
}

"An edge in a connection."
type PackageEdge {
    "A cursor for use in pagination"
    cursor: String!
    "The item at the end of the edge"
    node: Package!
}

input PackageInput {
    name: String!
    tagline: String!
    description: String!
    permissions: String
    tags: [String!]!
    webhook: WebhookInput
    visibility: PackageVisibility!
    patreon: Boolean! = false
    patreonTiers: [String!]! = [  ]
}

enum PackageVisibility {
    DRAFT
    PUBLIC
    UNLISTED
    PRIVATE
}

"Information about pagination in a connection"
type PageInfo {
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
    "When paginating forwards, the cursor to continue."
    endCursor: String
}

type Profile {
    description: String
    avatarId: String
    accent: String
    shape: String!
    links: JSON!
}

type QueryRoot {
    package(id: UUID!): Package
    variant(id: UUID!): Variant
    featuredPackages(page: Int! count: Int! filterInfo: FilterInfo): FeaturedPackages!
    packages(after: String before: String first: Int last: Int filterInfo: FilterInfo): PackageConnection!
    me: FullUser
    user(id: UUID!): User
    getVersion(id: UUID!): Version
    task(id: UUID!): Task
    categoryTags: [Tag!]!
    searchTags(query: String!): [TagSearchResult!]!
    searchAffects(query: String!): [String!]!
    searchVersions(info: SearchRequest! page: Int): SearchResult!
    recentlyUpdatedPackages(page: Int! count: Int! filterInfo: FilterInfo): RecentlyUpdatedPackages!
    checkVanityUrl(kind: VanityUrlKind! slug: String!): UUID
    convertVariantId(id: Int!): UUID
    convertVersionId(id: Int!): UUID
}

type RecentlyUpdatedPackage {
    package: Package!
    lastUpdated: DateTime!
}

type RecentlyUpdatedPackages {
    pageInfo: SimplePageInfo!
    packages: [RecentlyUpdatedPackage!]!
}

type RegisterResponse {
    id: UUID!
    username: String!
    token: String!
}

type RestrictedInfo {
    nsfw: Boolean!
    nsfl: Boolean!
}

enum SearchDirection {
    ASCENDING
    DESCENDING
}

input SearchRequest {
    name: String
    affects: [String!]! = [  ]
    includeTags: [String!]! = [  ]
    excludeTags: [String!]! = [  ]
    order: Order!
    direction: SearchDirection! = DESCENDING
}

type SearchResult {
    versions: [Version!]!
    hasNextPage: Boolean!
}

enum SelectionType {
    SINGLE
    MULTI
}

type SimplePageInfo {
    prev: Boolean!
    next: Boolean!
}

type Tag {
    slug: String!
    category: Boolean!
}

type TagSearchResult {
    slug: String!
    category: Boolean!
    packages: Int!
}

type Task {
    id: UUID!
    kind: String!
    createdAt: DateTime!
    updatedAt: DateTime!
    scheduledFor: DateTime!
    status: TaskStatus!
    retries: Int!
    output: JSON!
}

enum TaskStatus {
    QUEUED
    RUNNING
    SUCCESS
    FAILURE
}

type Tier {
    id: String!
    title: String!
    published: Boolean!
    amountUsdCents: Int!
    updatedAt: DateTime!
}

type Token {
    id: Int!
    userAgent: String
    updatedAt: DateTime!
    continent: String
    country: String
    city: String
}

"A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as\nStrings within GraphQL. UUIDs are used to assign unique identifiers to\nentities without requiring a central allocating authority.\n\n# References\n\n* [Wikipedia: Universally Unique Identifier](http:\/\/en.wikipedia.org\/wiki\/Universally_unique_identifier)\n* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http:\/\/tools.ietf.org\/html\/rfc4122)"
scalar UUID

input UpdatePackageInput {
    name: String
    tagline: String
    description: String
    vanityUrl: JSON!
    permissions: JSON!
    webhook: JSON! = "{\"kind\":\"ignore\"}"
    addTags: [String!]! = [  ]
    removeTags: [String!]! = [  ]
    visibility: PackageVisibility
    patreon: Boolean
    patreonTiers: [String!]
}

input UpdateProfileInput {
    description: JSON!
    vanityUrl: JSON!
    shape: String
    accent: JSON!
    links: JSON
}

input UpdateUserInput {
    username: String
    email: String
    newPassword: String
    password: String!
}

input UpdateVariantInput {
    name: String
}

input UpdateVersionInput {
    version: String
    changelog: JSON! = "{\"kind\":\"ignore\"}"
    variant: UUID
}

type User {
    id: UUID!
    username: String!
    subscriber: Boolean!
    vanityUrl: String
    packages(after: String before: String first: Int last: Int): PackageConnection!
    profile: Profile!
    patreonTiers: [Tier!]
    patreonPledgeUrl: String
}

enum VanityUrlKind {
    USER
    MOD
}

type Variant {
    id: UUID!
    name: String!
    packageId: UUID!
    package: Package!
    versions(limit: Int): [Version!]!
}

input VariantInput {
    packageId: UUID!
    name: String!
}

type Version {
    id: UUID!
    variantId: UUID!
    version: String!
    changelog: String
    createdAt: DateTime!
    updatedAt: DateTime!
    affects: [String!]!
    variant: Variant!
    installerImages: InstallerImages!
    gamePaths: [String!]!
    downloadSize: Int!
    installSize: Int!
    neededFiles(options: Options full: Boolean download: Boolean downloadKey: String): NeededFiles!
    groups: [Group!]!
    downloads: Int!
}

type Webhook {
    id: Int!
    createdAt: DateTime!
    url: String!
    nsfwImages: Boolean!
    userId: UUID
    packageId: UUID
}

input WebhookInput {
    url: String!
    nsfwImages: Boolean!
}
